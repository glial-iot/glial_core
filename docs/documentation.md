# Документация Glue

## Что такое Glue?  
**Glue** — это система управления IoT-устройствами, позволяющая реализовать бизнес-логику и взаимодействие устройств.

### Glue включает в себя:

- **механизм драйверов**, которые обеспечивают конвертацию приходящих от устройств данных в единый формат

- **механизм скриптов**, позволяющих обрабатывать данные с устройств и создавать логику верхнего уровня для определения того, как эти устройства будут работать вместе

- **центральную шину данных (bus)**, которая связывает между собой драйвера и логику

- **драйвера для различных TSDB** позволяют выгружать данные в различные TSDB для сбора статистики и последующего анализа

- **систему логгирования** для хранения и отображения событий, ошибок и предупреждений

## Режимы работы Glue  
Glue может работать в нескольких режимах.  

В режиме IMPACT все данные, поступающие с драйверов пересылаются в [Nokia IMPACT](https://networks.nokia.com/solutions/iot-platform)  

![режим IMPACT](images/glueImpactMode.png "режим IMPACT")  

В режиме Non-IMPACT, все данные хранятся в локальном key-value хранилище на базе платформы Tarantool.  

![режим Non-IMPACT](images/glueNonImpact.png "режим Non-IMPACT")   

## Состав системы  

### Компоненты системы  

Стандартный пакет установки Glue включает в себя:
- серверную часть ([сервис Glue](https://github.com/vvzvlad/glue)), написанную на Lua с использованием платформы Tarantool, осуществляющую получение, сбор, унификацию, хранение, обработку входящих данных и работу пользовательской логики
- клиентскую часть - панель управления ([Glue Panel](https://github.com/vvzvlad/glue_panel)), обеспечивающую визуализацию данных, создание, редактирование и отладку драйверов и скриптов и управление сервисом Glue

### Установка Glue
1. Установите [Tarantool](https://www.tarantool.io/en/download/)
1. Клонируйте репозиторий: ```git clone https://github.com/vvzvlad/glue.git && cd glue```
1. Установите http: ```sudo tarantoolctl rocks install http```
1. Установите mqtt: ```sudo tarantoolctl rocks install mqtt```
1. Установите dump: ```sudo tarantoolctl rocks install dump```
1. Запустите серверную часть: ```./glue.lua``` (запустится HTTP сервер на порту 8080)
1. Установите и запустите панель управления [Glue Webapp](https://github.com/vvzvlad/glue_web_app)
1. При необходимости, укажите адрес HTTP сервера Tarantool на странице настроек в панели управления, если он отличается от localhost:8080

### Панель управления  

Панель управления Glue включает в себя:
- таблицу данных, поступающих на центральную шину (bus) от различных устройств
- список логов, поступающих из различных скриптов и драйверов
- редактор драйверов и пользовательских скриптов (driver, web-event scripts, bus-event scripts, ...)
- страница с настройками

![Настройки Glue](images/managePanel.png "Настройки Glue")  

На странице с настройками можно 
- выбрать сервер, с которым будет работать панель
- выбрать TSDB, в которую будет происходить экспорт данных
- перезапустить сервис Glue
- перезапустить Glue с обновлением (выполняется git reset --hard, будут перезаписаны все изменения в коде Glue! )
- удалить все данные из центральной шины
- очистить все хранилище данных

## Bus  

Общая шина — это быстрая in-memory база данных ключ:значение, в которой ключом является стандартизованный адрес устройства или датчика, а значением — последние данные с этого устройства или датчика.  
Дополнительно, на шине хранится метаинформация - время получения последнего события, тип (единица измерения, например) и набор тегов.  

![Шина](images/busList.png "Шина")

Данные, поступающие в шину обновляются в веб-панели с интервалом, заданным пользователем (от 0.5 до 5 сек). Существует и возможность приостановить обновление данных.

Данные могут быть представлены в виде списка или древовидной иерархии, генерируемой на основе названия топика.

Экспорт значений можно включать и отключать индивидуально для каждого источника. Для экспорта может использоваться [InfluxData (InfluxDB)](https://www.influxdata.com/) или [Nokia IMPACT](https://networks.nokia.com/solutions/iot-platform).  

![Настройки TSDB](images/managePanel.png "Настройки TSDB")  

Включить экспорт данных в IMPACT или InfluxDB можно на странице настроек (пункт Manage в левом боковом меню).

## Scripts  
Скрипты — это обособленные части кода, которые реализуют прикладную логику: расчет, изменение, реакции, выдача данных.  
Скрипты бывают нескольких видов: 
- **drivers**
- **bus-event**
- **web-event**
- **timer-event** 

Cкрипты работают по следующему принципу: 
![Скрипты](images/eventAndTimerScripts.png "Скрипты")

В процсессе создания или редактирования пользовательских скриптов (драйверы, bus/web/timer-event scripts), доступны:  
- внутренние переменные
- функции логгирования
- функции для работы с центральной шиной

### Внутренние переменные скрипта
**script_name** - перменная, содержащая название текущего скрипта  
**_script_uuid** -  переменная, содержащая uuid (уникальный идентификатор) текущего скрипта  
**store** - таблица для хранения временных данных, уникальная для каждого скрипта.  Ее можно использовать просто как переменную:  
```lua
store.value = 5 
print(store.value) -- 5
```

### Функции для работы с логами

**log_info()** - добавляет в лог запись уровня "INFO"  
**log_warning()** - добавляет в лог запись уровня "WARNING"  
**log_error()** - добавляет в лог запись уровня "ERROR"  
**log_user()** - добавляет в лог запись уровня "USER"  
**log()** - аналогично функции log_user()  
**print()** - аналогично функции log_user()   

### Функции для работы с центральной шиной

**update_value(topic, value)**: Обновляет топик, устанавливая значение "value"   <!-- для всех скриптов написать, что они возвращают. но потом -->
**shadow_update_value(topic, value)**: Обновляет топик, устанавливая значение "value", но не запускает event-скрипты, которые подписаны на этот топик.
**get_value(topic)**: Получает значение и метаинформацию топика. Возвращает поля value, update_time, type, tags <!-- Расписать подробнее в подробном описании функии, что за поля и в каком виде -->
**bus_serialize(pattern)**: Получает содержимое центральной шины (bus) в виде вложенной таблицы. Если передана переменная "pattern", то будет выбрана только часть таблицы, соответствующая заданному шаблону. Шаблоны соответствуют правилам [lua patterns](https://www.lua.org/pil/20.2.html)

### Встроенные библиотеки  
Для использования этих библиотек не нужно делать require, они уже есть в области видимости каждого скрипта:  
**MQTT**(доступна через mqtt.xxx) [Документация по библиотеке MQTT](https://github.com/tarantool/mqtt)  
**JSON**(доступна через json.xxx) [Документация по библиотеке JSON](https://www.tarantool.io/en/doc/1.9/reference/reference_lua/json/)  
**SOCKET**(доступна через socket.xxx) [Документация по библиотеке SOCKET](https://www.tarantool.io/en/doc/1.9/reference/reference_lua/socket/)  
**FIBER**(доступна через fiber.xxx) Не стоит делать "local fiber = require 'fiber'". В этом случае, ошибки внутри тредов fiber не попадут в лог конкретного скрипта и не сгенерируют ошибку, что усложняет отладку. Доступны методы **sleep()**, **create()**, **kill()**, **yield()**, **self()**, **status()**. Для остальных нужно делать require и оборачивать функции, которые запускаются через **fiber.create()** в **pcall()**/**xpcall()**. [Документация по библиотеке FIBER](https://www.tarantool.io/en/doc/1.9/reference/reference_lua/fiber/)  
**HTTP Client**(уже созданный экземпляр доступен через http_client, т.е. для метода request() нужно вызвать http_client.request()) [Документация по библиотеке HTTP Client](https://www.tarantool.io/en/doc/1.9/reference/reference_lua/http/)  

Данные, поступающие из драйверов или скриптов, могут обновлять значение топика в стандартном (standard) или теневом (shadow) режиме. В первом случае, отработают все скрипты, которые подписаны на изменения значения топика, во втором случае, значение будет изменено без запуска скриптов. При обновлении самим скриптом топика, на который он подписан, коллбек в скрипте вызываться не будет.

![Обновление данных шины](images/glueBusUpdate.png "Обновление данных шины") 

Скрипты могут находиться в активном и неактивном состоянии.  
Скрипт, находящийся в активном состоянии, Glue будет пытаться включить непосредственно в момент активации и каждый раз при перезапуске. Скрипт можно принудительно перезапустить, если это необходимо.  
Неактивные скрипты никак не участвуют в работе системы до момента их активации.  

При успешном запуске скрипта, его статус изменяется на "Started". В случае, если возникли какие-либо ошибки, будет отображено что скрипт не запустился, а в логах будет указана причина ошибки.

![Статусы скриптов](images/scriptStatuses.png "Статусы скриптов") 

### Drivers
Драйвера — это скрипты на Lua, которые реализуют тот или иной протокол(часто с привлечением сторонних библиотек) для связи с устройством, конвертируя данные приходящие с каждого устройства в единый формат. Они работают в качестве транслятора между "языком" устройства и "языком" общей шины. 
 
Используя встроенный в Glue Panel редактор скриптов, вы можете создавать, тестировать и запускать скрипты драйверов на языке Lua.

![Список драйверов](images/driversList.png "Список драйверов")

Скрипты можно создавать, редактировать, включать/отключать, перезапускать и удалять.

![Редактирование скриптов драйвера](images/driverEdit.png "Редактирование скриптов драйвера")  

### Примеры драйверов

[Несколько примеров рабочих драйверов](drivers.md)

### Bus-event scripts  

Этот тип скриптов выполняется для каждого устройства из группы устройств, определяемых маской, при обновлении их данных на центральной шине.
![Bus-event scripts](images/busEventScriptList.png "Bus-event scripts")

При создании скрипта, необходимо использовать функцию **event_handler()**, в которую можно передать значение "value" и название топика соответствующего события на шине.  

```lua
function event_handler(value, topic)
   -- Ваш код здесь
end
```  

Пример кода, который прослушивает изменение показаний концентрации угарного газа CO на климатической станции и обновляет значение приращения этого значения для отслеживания динамики:  

```lua
function event_handler(value)
   store.old_value = store.old_value or 0
   difference =  value - store.old_value
   update_value("/wb/AN4SSJFL/vaisala/26651/CO_d", difference)

   store.old_value = value
end
```  

![Bus-event script](images/busEventScript.png "Bus-event script")  

### Web-event scripts

Скрипты, выполняемые при обращении к выбранному URL ("endpoint") с помощью HTTP запроса.  

![Web-event scripts](images/webScriptsList.png "Web-event scripts") 

Функция, реализующая непосредственную логику при обработке запроса - **http_callback()**.

При создании web-event скрипта, необходимо дать ему название и указать endpoint.  
Полный адрес скрипта формируется как **адрес_сервера:порт** + **/we/** + **endpoint** и отображается в нижней части модального окна как "Full script URL".

![Создание web-event скрипта](images/createWebEventScript.png "Создание web-event скрипта") 

В скриптах доступны переменные, содержащие данные запроса: 
- **params** - массив с параметрами запроса
- **req** - объект запроса [HTTP сервера Tarantool](https://github.com/tarantool/http)  

![Web-event script](images/webScript.png "Web-event script") 

```lua
function http_callback(params, req)
   -- Ваш код здесь
end
```  

Если в функции **http_callback()** вернуть одно значение-таблицу (напр. "return table"), то она будет сериализована в JSON и в таком виде отдана клиенту http-сервера.
Если необходимо управлять возвращаемыми данными напрямую, то надо вернуть 2 значения (напр. "return nil, 'OK'"), тогда первое значение будет отброшено, а второе - выдано клиенту в "сыром" виде без сериализации.  

Пример скрипта, который сериализует в JSON выборку данных из шины по маске _"/openweathermap/0/weatherstation"_ и отдает по HTTP при обращении:  

```lua
function http_callback(params)
   local data = bus_serialize("/openweathermap/0/weatherstation")
   return data.openweathermap["0"].weatherstation
end
```  

В результате обращения к endpoint'у скрипта "weather_stations", получаем данные, сериализованные в JSON:  

![Web-event script](images/webScriptResponse.png "Web-event script") 

### Timer-event scripts

Скрипты, выполняемые с определенным интервалом (указывается в секундах).

![Timer-event script](images/createTimerEventScript.png "Timer-event script")  

Для создания скрипта, укажите его название и желаемый интервал его выполнения в секундах.  

Код скрипта должен находиться внутри функции **event_handler()**.

```lua
function event_handler()
   --Ваш код здесь
end
```  

### Schedule scripts

Скрипты, выполняемые по заданному расписанию.

![Schedule script](images/scheduleScript.png "Schedule script")  

Для создания скрипта, укажите его название и расписание в формате [cron format](https://en.wikipedia.org/wiki/Cron).  
Формат был дополнен возможностью указания секунд в интервале (первый символ).  

```
# ┌───────────── секунды (0 - 59)
# │ ┌───────────── минуты (0 - 59)
# │ │ ┌───────────── часы (0 - 23)
# │ │ │ ┌───────────── дни месяца (1 - 31)
# │ │ │ │ ┌───────────── месяца (JAN-DEC или 1 - 12)
# │ │ │ │ │ ┌───────────── день недели (SUN-SAT или 0 - 6) (с Воскресения до Субботы)
# │ │ │ │ │ │
# │ │ │ │ │ │
# * * * * * *
```  

Также, доступны @monthly, @weekly, @daily, @hourly.

К примеру, с такими настройками расписания, скрипт будет запускаться по четвергам в 13:45:15

```
 15 45 13 * * 4 
```  

Код скрипта должен находиться внутри функции **event_handler()**.

```lua
function event_handler()
   --Ваш код здесь
end
```  